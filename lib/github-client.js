/**
 * GitHub API Client
 * Creates and manages GitHub issues for documentation audits
 */

import { Octokit } from '@octokit/rest';

/**
 * Format audit result as GitHub issue markdown
 */
function formatIssueBody(changelog, auditResult) {
  let body = `## Changelog Entry\n\n`;
  body += `**Title:** ${changelog.title}\n`;
  body += `**Published:** ${changelog.publishedAt}\n`;

  if (changelog.url) {
    body += `**Link:** ${changelog.url}\n`;
  }

  body += `\n---\n\n`;
  body += `## Summary\n\n`;
  body += auditResult.summary + '\n\n';

  body += `## Affected Articles (${auditResult.affected_articles.length})\n\n`;

  auditResult.affected_articles.forEach((article, index) => {
    body += `### ${index + 1}. ${article.article_title}\n\n`;
    body += `**Confidence:** ${article.confidence.toUpperCase()}\n\n`;
    body += `**Location:** \`${article.article_slug}\`\n\n`;
    body += `**Reason:** ${article.reason}\n\n`;

    if (article.specific_passage) {
      body += `**Current text:**\n`;
      body += `> ${article.specific_passage}\n\n`;
    }

    body += `**Suggested change:**\n`;
    body += article.suggested_change + '\n\n';

    body += `**Change type:** ${article.change_type}\n\n`;
    body += `---\n\n`;
  });

  body += `\nðŸ¤– Generated by [Documentation Audit System](https://github.com/sudowrite/docs-orchestration)`;

  return body;
}

/**
 * Generate labels for the issue
 */
function generateLabels(auditResult) {
  const labels = ['documentation', 'ai-audit'];

  // Add confidence-based labels
  const highConfidence = auditResult.affected_articles.filter(a => a.confidence === 'high');
  if (highConfidence.length > 0) {
    labels.push('high-priority');
  }

  // Add count-based labels
  if (auditResult.affected_articles.length > 5) {
    labels.push('large-update');
  }

  return labels;
}

/**
 * Create GitHub issue
 */
export async function createGitHubIssue({ changelog, auditResult }) {
  const token = process.env.GITHUB_TOKEN;
  const repo = process.env.GITHUB_REPO; // Format: "owner/repo"

  if (!token || !repo) {
    throw new Error('GITHUB_TOKEN or GITHUB_REPO not configured');
  }

  const [owner, repoName] = repo.split('/');

  if (!owner || !repoName) {
    throw new Error('GITHUB_REPO must be in format "owner/repo"');
  }

  const octokit = new Octokit({ auth: token });

  const title = `[Doc Audit] ${changelog.title}`;
  const body = formatIssueBody(changelog, auditResult);
  const labels = generateLabels(auditResult);

  const response = await octokit.issues.create({
    owner,
    repo: repoName,
    title,
    body,
    labels
  });

  return response.data;
}

/**
 * Update existing issue with new information
 */
export async function updateGitHubIssue(issueNumber, { changelog, auditResult }) {
  const token = process.env.GITHUB_TOKEN;
  const repo = process.env.GITHUB_REPO;

  if (!token || !repo) {
    throw new Error('GITHUB_TOKEN or GITHUB_REPO not configured');
  }

  const [owner, repoName] = repo.split('/');

  const octokit = new Octokit({ auth: token });

  const body = formatIssueBody(changelog, auditResult);

  const response = await octokit.issues.update({
    owner,
    repo: repoName,
    issue_number: issueNumber,
    body
  });

  return response.data;
}

/**
 * Close issue (after docs are updated)
 */
export async function closeGitHubIssue(issueNumber, comment) {
  const token = process.env.GITHUB_TOKEN;
  const repo = process.env.GITHUB_REPO;

  if (!token || !repo) {
    throw new Error('GITHUB_TOKEN or GITHUB_REPO not configured');
  }

  const [owner, repoName] = repo.split('/');

  const octokit = new Octokit({ auth: token });

  // Add closing comment
  if (comment) {
    await octokit.issues.createComment({
      owner,
      repo: repoName,
      issue_number: issueNumber,
      body: comment
    });
  }

  // Close the issue
  const response = await octokit.issues.update({
    owner,
    repo: repoName,
    issue_number: issueNumber,
    state: 'closed'
  });

  return response.data;
}
